{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/MafiaGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Treasury.sol\";\r\n\r\ncontract MafiaGame {\r\n\tenum Role {\r\n\t\tAssassin,\r\n\t\tPolice,\r\n\t\tCitizen\r\n\t}\r\n\tenum GameState {\r\n\t\tWaiting,\r\n\t\tAssigningRoles,\r\n\t\tNight,\r\n\t\tDay,\r\n\t\tFinalizing,\r\n\t\tFinished\r\n\t}\r\n\r\n\tstruct Player {\r\n\t\taddress playerAddress;\r\n\t\tRole role;\r\n\t\tbool isAlive;\r\n\t\tbool hasVoted;\r\n\t}\r\n\r\n\tTreasury public treasury;\r\n\tGameState public currentState;\r\n\taddress public activePlayer;\r\n\taddress[] public playerAddresses;\r\n\taddress[] public winners;\r\n\tmapping(address => Player) public players;\r\n\tmapping(address => uint) public votes;\r\n\r\n\tuint public totalVotes;\r\n\tuint public startTime;\r\n\taddress public lastKilled;\r\n\r\n\tevent GameStarted();\r\n\tevent RoleAssigned(address indexed player, Role role);\r\n\tevent NightNarration(address indexed killer, address indexed victim);\r\n\tevent PlayerVoted(address indexed voter, address indexed target);\r\n\tevent VotingRestarted();\r\n\tevent DayNarration(address indexed victim);\r\n\tevent VotingResult(\r\n\t\taddress indexed mostVoted,\r\n\t\tuint highestVotes,\r\n\t\tbool isTie\r\n\t);\r\n\tevent PrizeClaimed(address indexed winner, uint amount);\r\n\tevent GameEnded(address[] winners);\r\n\tevent GameReset();\r\n\r\n\tmodifier onlyActivePlayer() {\r\n\t\trequire(msg.sender == activePlayer, \"Only active player allowed\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyInState(GameState state) {\r\n\t\trequire(currentState == state, \"Invalid game state!\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyWinner() {\r\n\t\trequire(\r\n\t\t\twinners.length > 0 && winners[0] == activePlayer,\r\n\t\t\t\"Caller is not the winner!\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(address _treasuryAddress) {\r\n\t\ttreasury = Treasury(_treasuryAddress);\r\n\t\tcurrentState = GameState.Waiting;\r\n\t}\r\n\r\n\tfunction joinGame() external payable onlyInState(GameState.Waiting) {\r\n\t\trequire(msg.value == 0.1 ether, \"Must pay 0.1 ETH to join\");\r\n\t\trequire(playerAddresses.length == 0, \"Game already has active player\");\r\n\r\n\t\tactivePlayer = msg.sender;\r\n\t\tplayerAddresses.push(msg.sender);\r\n\t\tplayers[msg.sender] = Player(msg.sender, Role.Assassin, true, false);\r\n\t\ttreasury.deposit{ value: msg.value }(msg.sender);\r\n\r\n\t\taddVirtualPlayers();\r\n\t\tstartGame();\r\n\t}\r\n\r\n\tfunction addVirtualPlayers() private {\r\n\t\trequire(\r\n\t\t\taddress(this).balance >= 0.3 ether,\r\n\t\t\t\"Insufficient balance for virtual players\"\r\n\t\t);\r\n\r\n\t\tfor (uint i = 1; i <= 3; i++) {\r\n\t\t\taddress virtualPlayer = address(uint160(i));\r\n\t\t\tplayerAddresses.push(virtualPlayer);\r\n\t\t\ttreasury.deposit{ value: 0.1 ether }(virtualPlayer);\r\n\t\t\tplayers[virtualPlayer] = Player(\r\n\t\t\t\tvirtualPlayer,\r\n\t\t\t\tRole(\r\n\t\t\t\t\ti == 1\r\n\t\t\t\t\t\t? Role.Assassin\r\n\t\t\t\t\t\t: i == 2\r\n\t\t\t\t\t\t\t? Role.Police\r\n\t\t\t\t\t\t\t: Role.Citizen\r\n\t\t\t\t),\r\n\t\t\t\ttrue,\r\n\t\t\t\tfalse\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction startGame() private {\r\n\t\tcurrentState = GameState.AssigningRoles;\r\n\t\tstartTime = block.timestamp;\r\n\t\temit GameStarted();\r\n\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\temit RoleAssigned(\r\n\t\t\t\tplayerAddresses[i],\r\n\t\t\t\tplayers[playerAddresses[i]].role\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tcurrentState = GameState.Night;\r\n\t}\r\n\r\n\tfunction assassinKill(\r\n\t\taddress target\r\n\t) external onlyActivePlayer onlyInState(GameState.Night) {\r\n\t\trequire(players[target].isAlive, \"Target is already dead!\");\r\n\r\n\t\tplayers[target].isAlive = false;\r\n\t\tlastKilled = target;\r\n\t\tstartTime = block.timestamp;\r\n\t\tcurrentState = GameState.Day;\r\n\t\temit NightNarration(msg.sender, target);\r\n\t}\r\n\r\n\tfunction voteToKill(\r\n\t\taddress target\r\n\t) external onlyActivePlayer onlyInState(GameState.Day) {\r\n\t\trequire(players[target].isAlive, \"Target is already dead!\");\r\n\t\tplayers[activePlayer].hasVoted = true;\r\n\t\tvotes[target]++;\r\n\t\ttotalVotes = 3;\r\n\r\n\t\tplayers[target].isAlive = false;\r\n\t\tlastKilled = target;\r\n\t\tcurrentState = GameState.Finalizing;\r\n\t\twinners.push(activePlayer);\r\n\r\n\t\temit PlayerVoted(activePlayer, target);\r\n\t\temit DayNarration(target);\r\n\t\temit VotingResult(target, votes[target], false);\r\n\t}\r\n\r\n\tfunction resetVoting() private {\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tplayers[playerAddresses[i]].hasVoted = false;\r\n\t\t\tvotes[playerAddresses[i]] = 0;\r\n\t\t}\r\n\t\ttotalVotes = 0;\r\n\t\tstartTime = block.timestamp;\r\n\t}\r\n\r\n\tfunction claimPrize()\r\n\t\texternal\r\n\t\tonlyActivePlayer\r\n\t\tonlyWinner\r\n\t\tonlyInState(GameState.Finalizing)\r\n\t{\r\n\t\tuint totalPrize = treasury.getBalance();\r\n\t\ttreasury.distributePrize(payable(activePlayer), totalPrize);\r\n\r\n\t\tcurrentState = GameState.Finished;\r\n\t\tresetGame();\r\n\t\temit GameEnded(winners);\r\n\t}\r\n\r\n\tfunction resetGame() private {\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tdelete players[playerAddresses[i]];\r\n\t\t\tdelete votes[playerAddresses[i]];\r\n\t\t}\r\n\r\n\t\ttreasury.resetBalances(playerAddresses);\r\n\t\tdelete playerAddresses;\r\n\t\tdelete winners;\r\n\t\tdelete lastKilled;\r\n\t\tdelete activePlayer;\r\n\t\ttotalVotes = 0;\r\n\t\tstartTime = 0;\r\n\t\tcurrentState = GameState.Waiting;\r\n\t\temit GameReset();\r\n\t}\r\n\r\n\tfunction getAllPlayers() public view returns (Player[] memory) {\r\n\t\tPlayer[] memory allPlayers = new Player[](playerAddresses.length);\r\n\t\tfor (uint256 i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tallPlayers[i] = players[playerAddresses[i]];\r\n\t\t}\r\n\t\treturn allPlayers;\r\n\t}\r\n\r\n\tfunction getAllWinners() public view returns (address[] memory) {\r\n\t\taddress[] memory allWinners = new address[](1);\r\n\t\tallWinners[0] = activePlayer;\r\n\r\n\t\treturn allWinners;\r\n\t}\r\n\r\n\treceive() external payable {}\r\n}\r\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Treasury is Ownable(msg.sender) {\r\n\taddress public mafiaGame;\r\n\tmapping(address => uint) public balances;\r\n\r\n\tmodifier onlyMafiaGame() {\r\n\t\trequire(\r\n\t\t\tmsg.sender == mafiaGame,\r\n\t\t\t\"Only MafiaGame can call this function\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction setMafiaGameAddress(address _mafiaGame) external onlyOwner {\r\n\t\trequire(_mafiaGame != address(0), \"Invalid MafiaGame address\");\r\n\t\tmafiaGame = _mafiaGame;\r\n\t}\r\n\r\n\tfunction deposit(address player) external payable onlyMafiaGame {\r\n\t\trequire(msg.value > 0, \"Deposit must be greater than zero\");\r\n\t\tbalances[player] += msg.value;\r\n\t}\r\n\r\n\tfunction withdraw(address payable to) external onlyMafiaGame {\r\n\t\tuint amount = balances[to];\r\n\t\trequire(amount > 0, \"No funds to withdraw\");\r\n\r\n\t\tbalances[to] = 0;\r\n\t\tto.transfer(amount);\r\n\t}\r\n\r\n\tfunction distributePrize(\r\n\t\taddress payable recipient,\r\n\t\tuint amount\r\n\t) external onlyMafiaGame {\r\n\t\trequire(address(this).balance >= amount, \"Not enough funds\");\r\n\t\tbalances[recipient] = 0;\r\n\t\trecipient.transfer(amount);\r\n\t}\r\n\r\n\tfunction getBalance() external view returns (uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n\tfunction resetBalances(\r\n\t\taddress[] memory playerAddresses\r\n\t) external onlyMafiaGame {\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tbalances[playerAddresses[i]] = 0;\r\n\t\t}\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}