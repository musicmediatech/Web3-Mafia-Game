{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/MafiaGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Treasury.sol\";\r\n\r\ncontract MafiaGame {\r\n\tenum Role {\r\n\t\tAssassin,\r\n\t\tPolice,\r\n\t\tCitizen\r\n\t}\r\n\tenum GameState {\r\n\t\tWaiting,\r\n\t\tAssigningRoles,\r\n\t\tNight,\r\n\t\tDay,\r\n\t\tFinalizing,\r\n\t\tFinished\r\n\t}\r\n\r\n\tstruct Player {\r\n\t\taddress playerAddress;\r\n\t\tRole role;\r\n\t\tbool isAlive;\r\n\t\tbool hasVoted;\r\n\t}\r\n\tstruct VoteResult {\r\n\t\taddress mostVoted;\r\n\t\tuint highestVotes;\r\n\t\tbool isTie;\r\n\t}\r\n\r\n\tTreasury public treasury;\r\n\tGameState public currentState;\r\n\r\n\tmapping(address => Player) public players;\r\n\tmapping(address => uint) public votes;\r\n\taddress[] public playerAddresses;\r\n\taddress[] public winners;\r\n\r\n\tuint public totalVotes;\r\n\tuint public startTime;\r\n\taddress public lastKilled;\r\n\r\n\tevent GameStarted();\r\n\tevent RoleAssigned(address indexed player, Role role);\r\n\tevent NightNarration(address indexed killer, address indexed victim);\r\n\tevent PlayerVoted(address indexed voter, address indexed target);\r\n\tevent VotingRestarted();\r\n\tevent DayNarration(address indexed victim);\r\n\tevent VotingResult(\r\n\t\taddress indexed mostVoted,\r\n\t\tuint highestVotes,\r\n\t\tbool isTie\r\n\t);\r\n\tevent PrizeClaimed(address indexed winner, uint amount);\r\n\tevent GameEnded(address[] winners);\r\n\tevent GameReset();\r\n\r\n\tmodifier onlyAlive() {\r\n\t\trequire(players[msg.sender].isAlive, \"You are dead!\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyInState(GameState state) {\r\n\t\trequire(currentState == state, \"Invalid game state!\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyWinner(address caller) {\r\n\t\tbool isWinner = false;\r\n\t\tfor (uint i = 0; i < winners.length; i++) {\r\n\t\t\tif (winners[i] == caller) {\r\n\t\t\t\tisWinner = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(isWinner, \"Caller is not a winner!\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyAssassin() {\r\n\t\trequire(\r\n\t\t\tplayers[msg.sender].role == Role.Assassin,\r\n\t\t\t\"You are not an assassin!\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(address _treasuryAddress) {\r\n\t\ttreasury = Treasury(_treasuryAddress);\r\n\t\tcurrentState = GameState.Waiting;\r\n\t}\r\n\r\n\tfunction joinGame() external payable onlyInState(GameState.Waiting) {\r\n\t\trequire(msg.value == 0.1 ether, \"Must pay 0.1 ETH to join\");\r\n\t\trequire(playerAddresses.length < 4, \"Game is full\");\r\n\t\trequire(\r\n\t\t\tplayers[msg.sender].playerAddress == address(0),\r\n\t\t\t\"Player has already joined\"\r\n\t\t);\r\n\r\n\t\tplayers[msg.sender] = Player(msg.sender, Role.Citizen, true, false);\r\n\t\tplayerAddresses.push(msg.sender);\r\n\t\ttreasury.deposit{ value: msg.value }(msg.sender);\r\n\r\n\t\tif (playerAddresses.length == 4) {\r\n\t\t\tstartGame();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction startGame() private {\r\n\t\tcurrentState = GameState.AssigningRoles;\r\n\t\tstartTime = block.timestamp;\r\n\t\temit GameStarted();\r\n\t\tassignRoles();\r\n\t}\r\n\r\n\tfunction assignRoles() private {\r\n\t\tplayers[playerAddresses[0]].role = Role.Assassin;\r\n\t\tplayers[playerAddresses[1]].role = Role.Assassin;\r\n\t\tplayers[playerAddresses[2]].role = Role.Police;\r\n\t\tplayers[playerAddresses[3]].role = Role.Citizen;\r\n\r\n\t\tfor (uint256 i = 0; i < playerAddresses.length; i++) {\r\n\t\t\temit RoleAssigned(\r\n\t\t\t\tplayerAddresses[i],\r\n\t\t\t\tplayers[playerAddresses[i]].role\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tcurrentState = GameState.Night;\r\n\t\tstartTime = block.timestamp;\r\n\t}\r\n\r\n\tfunction assassinKill(\r\n\t\taddress target\r\n\t) external onlyAssassin onlyInState(GameState.Night) onlyAlive {\r\n\t\trequire(players[target].isAlive, \"Target is already dead!\");\r\n\t\trequire(target != msg.sender, \"Assassin cannot kill themselves!\");\r\n\r\n\t\tplayers[target].isAlive = false;\r\n\t\tlastKilled = target;\r\n\t\tstartTime = block.timestamp;\r\n\t\tcurrentState = GameState.Day;\r\n\t\temit NightNarration(msg.sender, target);\r\n\t}\r\n\r\n\tfunction voteToKill(\r\n\t\taddress target\r\n\t) external onlyAlive onlyInState(GameState.Day) {\r\n\t\trequire(!players[msg.sender].hasVoted, \"You have already voted!\");\r\n\t\trequire(players[target].isAlive, \"Target is already dead!\");\r\n\r\n\t\tplayers[msg.sender].hasVoted = true;\r\n\t\tvotes[target]++;\r\n\t\ttotalVotes++;\r\n\r\n\t\tcheckVoteResult();\r\n\t\temit PlayerVoted(msg.sender, target);\r\n\t}\r\n\r\n\tfunction checkVoteResult() private onlyAlive onlyInState(GameState.Day) {\r\n\t\tVoteResult memory result = _tallyVotes();\r\n\r\n\t\tif (!result.isTie && (totalVotes == 3 || hasStageEnded())) {\r\n\t\t\tplayers[result.mostVoted].isAlive = false;\r\n\t\t\tlastKilled = result.mostVoted;\r\n\t\t\tcurrentState = GameState.Finalizing;\r\n\t\t\tcheckWinners();\r\n\t\t\temit DayNarration(result.mostVoted);\r\n\t\t} else if (hasStageEnded()) {\r\n\t\t\tresetVoting();\r\n\t\t\temit VotingRestarted();\r\n\t\t}\r\n\r\n\t\temit VotingResult(result.mostVoted, result.highestVotes, result.isTie);\r\n\t}\r\n\r\n\tfunction _tallyVotes() private view returns (VoteResult memory) {\r\n\t\tVoteResult memory result;\r\n\t\tuint highestVotes = 0;\r\n\t\tbool isTie = false;\r\n\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\taddress player = playerAddresses[i];\r\n\t\t\tif (players[player].isAlive) {\r\n\t\t\t\tif (votes[player] > highestVotes) {\r\n\t\t\t\t\thighestVotes = votes[player];\r\n\t\t\t\t\tresult.mostVoted = player;\r\n\t\t\t\t\tisTie = false;\r\n\t\t\t\t} else if (votes[player] == highestVotes && highestVotes > 0) {\r\n\t\t\t\t\tisTie = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.highestVotes = highestVotes;\r\n\t\tresult.isTie = isTie;\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction resetVoting() private {\r\n\t\tfor (uint256 i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tplayers[playerAddresses[i]].hasVoted = false;\r\n\t\t\tvotes[playerAddresses[i]] = 0;\r\n\t\t}\r\n\t\ttotalVotes = 0;\r\n\t\tstartTime = block.timestamp;\r\n\t}\r\n\r\n\tfunction checkWinners() private {\r\n\t\tuint256 aliveAssassins;\r\n\t\tdelete winners;\r\n\r\n\t\tfor (uint256 i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tif (!players[playerAddresses[i]].isAlive) continue;\r\n\r\n\t\t\tRole role = players[playerAddresses[i]].role;\r\n\r\n\t\t\tif (role == Role.Assassin) {\r\n\t\t\t\taliveAssassins++;\r\n\t\t\t} else {\r\n\t\t\t\twinners.push(playerAddresses[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (aliveAssassins > 0) {\r\n\t\t\tdelete winners;\r\n\t\t\tfor (uint256 i = 0; i < playerAddresses.length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tplayers[playerAddresses[i]].isAlive &&\r\n\t\t\t\t\tplayers[playerAddresses[i]].role == Role.Assassin\r\n\t\t\t\t) {\r\n\t\t\t\t\twinners.push(playerAddresses[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction claimPrize()\r\n\t\texternal\r\n\t\tonlyAlive\r\n\t\tonlyWinner(msg.sender)\r\n\t\tonlyInState(GameState.Finalizing)\r\n\t{\r\n\t\tuint totalPrize = treasury.getBalance();\r\n\t\tuint prizePerWinner = totalPrize / winners.length;\r\n\r\n\t\ttreasury.distributePrize(payable(msg.sender), prizePerWinner);\r\n\t\t_removeWinner(msg.sender);\r\n\r\n\t\tif (winners.length == 0) {\r\n\t\t\tcurrentState = GameState.Finished;\r\n\t\t\tresetGame();\r\n\t\t\temit GameEnded(winners);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _removeWinner(address winner) private {\r\n\t\tfor (uint i = 0; i < winners.length; i++) {\r\n\t\t\tif (winners[i] == winner) {\r\n\t\t\t\twinners[i] = winners[winners.length - 1];\r\n\t\t\t\twinners.pop();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction resetGame() private onlyInState(GameState.Finished) {\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tdelete players[playerAddresses[i]];\r\n\t\t\tdelete votes[playerAddresses[i]];\r\n\t\t}\r\n\r\n\t\ttreasury.resetBalances(playerAddresses);\r\n\t\tdelete playerAddresses;\r\n\t\tdelete lastKilled;\r\n\t\tdelete totalVotes;\r\n\t\tdelete winners;\r\n\t\tstartTime = 0;\r\n\t\tcurrentState = GameState.Waiting;\r\n\r\n\t\temit GameReset();\r\n\t}\r\n\r\n\tfunction hasStageEnded() public view returns (bool) {\r\n\t\treturn (block.timestamp >= startTime + currentStageDuration());\r\n\t}\r\n\r\n\tfunction currentStageDuration() public view returns (uint) {\r\n\t\tif (currentState == GameState.AssigningRoles) {\r\n\t\t\treturn 30 seconds;\r\n\t\t} else if (currentState == GameState.Night) {\r\n\t\t\treturn 30 seconds;\r\n\t\t} else if (currentState == GameState.Day) {\r\n\t\t\treturn 60 seconds;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getAllPlayers() public view returns (Player[] memory) {\r\n\t\tPlayer[] memory allPlayers = new Player[](playerAddresses.length);\r\n\t\tfor (uint256 i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tallPlayers[i] = players[playerAddresses[i]];\r\n\t\t}\r\n\t\treturn allPlayers;\r\n\t}\r\n\r\n\tfunction getAllWinners() public view returns (address[] memory) {\r\n\t\taddress[] memory allWinners = new address[](winners.length);\r\n\t\tfor (uint256 i = 0; i < winners.length; i++) {\r\n\t\t\tallWinners[i] = winners[i];\r\n\t\t}\r\n\t\treturn allWinners;\r\n\t}\r\n}\r\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Treasury is Ownable(msg.sender) {\r\n\taddress public mafiaGame;\r\n\tmapping(address => uint) public balances;\r\n\r\n\tmodifier onlyMafiaGame() {\r\n\t\trequire(\r\n\t\t\tmsg.sender == mafiaGame,\r\n\t\t\t\"Only MafiaGame can call this function\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction setMafiaGameAddress(address _mafiaGame) external onlyOwner {\r\n\t\trequire(_mafiaGame != address(0), \"Invalid MafiaGame address\");\r\n\t\tmafiaGame = _mafiaGame;\r\n\t}\r\n\r\n\tfunction deposit(address player) external payable onlyMafiaGame {\r\n\t\trequire(msg.value > 0, \"Deposit must be greater than zero\");\r\n\t\tbalances[player] += msg.value;\r\n\t}\r\n\r\n\tfunction withdraw(address payable to) external onlyMafiaGame {\r\n\t\tuint amount = balances[to];\r\n\t\trequire(amount > 0, \"No funds to withdraw\");\r\n\r\n\t\tbalances[to] = 0;\r\n\t\tto.transfer(amount);\r\n\t}\r\n\r\n\tfunction distributePrize(\r\n\t\taddress payable recipient,\r\n\t\tuint amount\r\n\t) external onlyMafiaGame {\r\n\t\trequire(address(this).balance >= amount, \"Not enough funds\");\r\n\t\tbalances[recipient] = 0;\r\n\t\trecipient.transfer(amount);\r\n\t}\r\n\r\n\tfunction getBalance() external view returns (uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n\tfunction resetBalances(\r\n\t\taddress[] memory playerAddresses\r\n\t) external onlyMafiaGame {\r\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\r\n\t\t\tbalances[playerAddresses[i]] = 0;\r\n\t\t}\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}